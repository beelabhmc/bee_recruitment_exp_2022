---
title: "R Notebook"
output: html_notebook
---

# Purpose

This script uses generalized linear mixed models to examine the effects of density and number of flowers on the number/rate of dances that bees performed and the number of waggle runs performed per dance. The data are from experiments using arrays of artificial flowers conducted in the summer of 2022.


# Set up working directory

```{r, setup} 
library(knitr) 
opts_knit$set(root.dir = normalizePath('../'))
```


# Load libraries

```{r}
library("tidyverse")  # for wrangling data
library("lme4")       # for glmer.nb function
library("nlme")       # for lme function
library("glmmTMB")    # for fitting generalized mixed models
library("bbmle") # for making delta AIC comparison table
library("DHARMa")     # to assess generalized mixed models
```


# Step : Read in data files

```{r}
# This file has one row per dance
dances_df <- read.csv("cleaned_data/02_all_dances.csv") %>%
  mutate(ObsID = row_number())

# This file has one row per uniquely-IDed bee
bees_df <- read.csv("cleaned_data/02_per_bee_summary.csv") %>%
  mutate(ObsID = row_number())

```


# Step : Fitting a set of generalized mixed models

```{r}
model_dance_olrs <- glmmTMB(Dances ~ Density + Flower_number +
                          (1|Date) + (1|Trial) + (1|Bee) + (1|ObsID),
                        family = "poisson", 
                        data = bees_df)

model_dance_nb1 <- glmmTMB(Dances ~ Density + Flower_number + 
                          (1|Date) + (1|Trial) + (1|Bee), 
                         family = "nbinom1", 
                         data = bees_df)

model_dance_nb2 <- glmmTMB(Dances ~ Density + Flower_number + 
                          (1|Date) + (1|Trial) +  (1|Bee), 
                         family="nbinom2", 
                         data = bees_df)

model_dance_zip <- glmmTMB(Dances ~ Density + Flower_number + 
                          (1|Date) + (1|Trial) + (1|Bee),  
                          zi = ~1,
                          family="poisson", 
                          data = bees_df)
```

```{r}
AICtab(model_dance_olrs,
       model_dance_nb1,
       model_dance_nb2,
       model_dance_zip)
```

```{r}
summary(model_dance_olrs)
```

```{r}
simulationOutput_olrs <- simulateResiduals(
  fittedModel = model_dance_olrs, plot = FALSE)

plot(simulationOutput_olrs)
```


```{r}
summary(model_dance_nb1)
```

```{r}
simulationOutput_nb1 <- simulateResiduals(
  fittedModel = model_dance_nb1, plot = FALSE)

plot(simulationOutput_nb1)
```

```{r}
summary(model_dance_nb2)
```

```{r}
simulationOutput_nb2 <- simulateResiduals(
  fittedModel = model_dance_nb2, plot = FALSE)

plot(simulationOutput_nb2)
```

```{r}
summary(model_dance_zip)
```

```{r}
simulationOutput_zip <- simulateResiduals(
  fittedModel = model_dance_zip, plot = FALSE)

plot(simulationOutput_zip)
```


# Step : Dance rate per bee (dances/hour) model

* __Question__: If we were to use dance rate rather than dances per bee, then we can't use a negative binomial generalized model because we no longer have count data. I tried just a normal mixed model (see below), but you can see below that the residuals are not normally distributed. Maybe this is moot point if we are going with dances per bee, but what would you recommend?

```{r}
model_dance_rate <- lme(Dance_rate ~ Density + Flower_number + Trial,
                        random = ~1|Date,
                        data = bees_df)

summary(model_dance_rate)
```

Testing model fit with plot:

```{r}
qqnorm(resid(model_dance_rate))
qqline(resid(model_dance_rate))
```
This seems worrying, but I wanted to clearer answer about whether the residuals were normally-distributed. Unfortunately, the DHARMa package does not seem to work for lme models.

I wanted to use a Kolmogorov-Smirnov test to see if the residuals are normally distributed so that it was consistent with the DHARMa output, but it can't handle ties so I used a Shapiro-Wilk test instead:

```{r}
shapiro.test(resid(model_dance_rate))
```

So that's clearly not normal.

My next thought was to try some transformations, but none of the standard transformations I tried helped (log+1, sqrt, square).


# Step : Waggle runs/dance model comparison

```{r}
model_runs_olrs <- glmmTMB(Total_runs ~ Density + Flower_number +
                          (1|Date) + (1|Trial) + (1|Bee) + (1|ObsID),
                        family = "poisson", 
                        data = dances_df)

model_runs_nb1 <- glmmTMB(Total_runs ~ Density + Flower_number + 
                          (1|Date) + (1|Trial) + (1|Bee), 
                         family = "nbinom1", 
                         data = dances_df)

model_runs_nb2 <- glmmTMB(Total_runs ~ Density + Flower_number + 
                          (1|Date) + (1|Trial) +  (1|Bee), 
                         family="nbinom2", 
                         data = dances_df)
```

```{r}
AICtab(model_runs_olrs,
       model_runs_nb1,
       model_runs_nb2)
```

```{r}
summary(model_runs_olrs)
```

```{r}
simulationOutput_runs_olrs <- simulateResiduals(
  fittedModel = model_runs_olrs, plot = FALSE)

plot(simulationOutput_runs_olrs)
```

```{r}
summary(model_runs_nb1)
```

```{r}
simulationOutput_runs_nb1 <- simulateResiduals(
  fittedModel = model_runs_nb1, plot = FALSE)

plot(simulationOutput_runs_nb1)
```

```{r}
summary(model_runs_nb2)
```

```{r}
simulationOutput_runs_nb2 <- simulateResiduals(
  fittedModel = model_runs_nb2, plot = FALSE)

plot(simulationOutput_runs_nb2)
```

```{r}
summary(model_runs_zip)
```

```{r}
simulationOutput_runs_zip <- simulateResiduals(
  fittedModel = model_runs_zip, plot = FALSE)

plot(simulationOutput_runs_zip)
```